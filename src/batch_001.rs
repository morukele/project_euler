pub fn prob_1(n: i32) -> i32 {
    let mut sum = 0;
    for i in 0..n {
        if i % 3 == 0 || i % 5 == 0 {
            sum += i;
        }
    }

    sum
}

// A function that returns the sum of the even numbers in the n Fibonacci numbers
pub fn prob_2(n: i32) -> i32 {
    let mut total = 0;
    let (mut a, mut b) = (1, 1);

    while a <= n {
        // Check if the number is even
        if a % 2 == 0 {
            total += a;
        }
        (a, b) = (b, a + b); // update the Fibonacci sequence
    }

    total
}

// A function to return the largest prime factor of a number n
pub fn prob_3(mut n: i64) -> i64 {
    let mut divisor = 2;

    while n > 1 {
        if n % divisor == 0 {
            n /= divisor
        } else {
            divisor += 1;
        }
    }

    divisor
}

// A function that returns the largest palindromic number made from the product of two 3-digit numbers
pub fn prob_4() -> i64 {
    // THIS IS A GREEDY ALGORITHM
    let mut res = 0;
    for i in (100..=999).rev() {
        for j in (100..=i).rev() {
            let product = i * j;
            let string = product.to_string();
            let rstring: String = string.chars().rev().collect();
            if string == rstring && product > res {
                res = product
            }
        }
    }

    res
}

// A function that gives the smallest positive number that is evenly divisible by all  of the numbers from 1 to 20
pub fn prob_5(n: i64) -> i64 {
    // let mut solution = 0;
    // let mut solved = false;
    // let mut potential_solution = n; // using this because in theory the largest number must be able to divide the solution

    // while solved == false {
    //     for i in 1..=n {
    //         if potential_solution % i != 0 {
    //             break;
    //         } else {
    //             if i == n {
    //                 solution = potential_solution;
    //                 solved = true;
    //             }
    //         }
    //     }

    //     potential_solution += 1;
    // }

    // solution

    // - A more optimal solution proposed by Claude Sonnet 3.5
    let mut res = 1;
    for i in 1..=n {
        res = lcm(res, i);
    }

    res
}

// Calculate the greatest common divisor using Euclidean algorithm.
fn gcd(mut a: i64, mut b: i64) -> i64 {
    while b > 0 {
        (a, b) = (b, a % b)
    }

    a
}

// Calculate the Least Common Multiple using GCD
fn lcm(a: i64, b: i64) -> i64 {
    (a * b) / gcd(a, b)
}

// A function to compute the difference between the sum of the squares and the squre of the sum of first n numbers
pub fn prob_6(n: i64) -> i64 {
    // let mut sum_of_square = 0;
    // let mut sum = 0;

    // for i in 1..=n {
    //     // sume of the square
    //     sum_of_square += i * i;

    //     // squre of the sum
    //     sum += i;
    // }

    // (sum * sum) - sum_of_square

    // A more optimal solution generated by Claude Sonnet 3.5
    let sum = n * (n + 1) / 2;
    let sum_of_squares = n * (n + 1) * (2 * n + 1) / 6;

    (sum * sum) - sum_of_squares
}

// A function to return the nth prome number
pub fn prob_7(n: i64) -> i64 {
    let mut count = 1; // we know that 2 is a prime number
    let mut candidate = 1;
    while count < n {
        candidate += 2;
        if is_prime(candidate) {
            count += 1
        }
    }

    candidate
}

fn is_prime(n: i64) -> bool {
    if n == 1 {
        return false;
    } else if n < 4 {
        return true; // 2 and 3 are prime numbers
    } else if n % 2 == 0 {
        return false;
    } else if n < 9 {
        return true; // we already excluded 4, 6, 8
    } else if n % 3 == 0 {
        return false; // can clearly be divided by a number that is not 1 or itself. NB: we have excluded 3 itself
    } else {
        let r = (n as f64).sqrt() as i64; // round to the greatest integer so that r*r <= n
        let mut f = 5;
        while f <= r {
            if n % f == 0 || n % (f + 2) == 0 {
                return false;
            }
            f = f + 6;
        }
    }

    true
}

pub fn prob_8(n: i64) -> i64 {
    let digits = "73167176531330624919225119674426574742355349194934
    96983520312774506326239578318016984801869478851843
    85861560789112949495459501737958331952853208805511
    12540698747158523863050715693290963295227443043557
    66896648950445244523161731856403098711121722383113
    62229893423380308135336276614282806444486645238749
    30358907296290491560440772390713810515859307960866
    70172427121883998797908792274921901699720888093776
    65727333001053367881220235421809751254540594752243
    52584907711670556013604839586446706324415722155397
    53697817977846174064955149290862569321978468622482
    83972241375657056057490261407972968652414535100474
    82166370484403199890008895243450658541227588666881
    16427171479924442928230863465674813919123162824586
    17866458359124566529476545682848912883142607690042
    24219022671055626321111109370544217506941658960408
    07198403850962455444362981230987879927244284909188
    84580156166097919133875499200524063689912560717606
    05886116467109405077541002256983155200055935729725
    71636269561882670428252483600823257530420752963450"
        .to_string();

    // concert input to a vec of integers
    let digits: Vec<i64> = digits
        .chars()
        .filter(|c| c.is_digit(10))
        .map(|c| c.to_digit(10).unwrap() as i64)
        .collect();

    // Compute the n adjacent numbers using a sliding window and selecting the max
    digits
        .windows(n as usize)
        .map(|window| window.iter().product())
        .max()
        .unwrap_or(0)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn prob_1_test() {
        let sum = prob_1(10);
        assert_eq!(sum, 23);
    }

    #[test]
    fn prob_2_test() {
        let res = prob_2(89);
        assert_eq!(res, 44);
    }

    #[test]
    fn prob_3_test() {
        let res = prob_3(13195);
        assert_eq!(res, 29);
    }

    #[test]
    fn prob_4_test() {
        let res = prob_4();
        assert_eq!(res, 906609);
    }

    #[test]
    fn prob_5_test() {
        let res = prob_5(10);
        assert_eq!(res, 2520);
    }

    #[test]
    fn prob_6_test() {
        let res = prob_6(10);
        assert_eq!(res, 2640);
    }

    #[test]
    fn prob_7_test() {
        let res = prob_7(6);
        assert_eq!(res, 13);
    }

    #[test]
    fn prob_8_test() {
        let res = prob_8(4);
        assert_eq!(res, 5832);
    }
}
