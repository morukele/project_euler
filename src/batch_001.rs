pub fn prob_1(n: i32) -> i32 {
    let mut sum = 0;
    for i in 0..n {
        if i % 3 == 0 || i % 5 == 0 {
            sum += i;
        }
    }

    sum
}

// A function that returns the sum of the even numbers in the n Fibonacci numbers
pub fn prob_2(n: i32) -> i32 {
    let mut total = 0;
    let (mut a, mut b) = (1, 1);

    while a <= n {
        // Check if the number is even
        if a % 2 == 0 {
            total += a;
        }
        (a, b) = (b, a + b); // update the Fibonacci sequence
    }

    total
}

// A function to return the largest prime factor of a number n
pub fn prob_3(mut n: i64) -> i64 {
    let mut divisor = 2;

    while n > 1 {
        if n % divisor == 0 {
            n /= divisor
        } else {
            divisor += 1;
        }
    }

    divisor
}

// A function that returns the largest palindromic number made from the product of two 3-digit numbers
pub fn prob_4() -> i64 {
    // THIS IS A GREEDY ALGORITHM
    let mut res = 0;
    for i in (100..=999).rev() {
        for j in (100..=i).rev() {
            let product = i * j;
            let string = product.to_string();
            let rstring: String = string.chars().rev().collect();
            if string == rstring && product > res {
                res = product
            }
        }
    }

    res
}

// A function that gives the smallest positive number that is evenly divisible by all  of the numbers from 1 to 20
pub fn prob_5(n: i64) -> i64 {
    // let mut solution = 0;
    // let mut solved = false;
    // let mut potential_solution = n; // using this because in theory the largest number must be able to divide the solution

    // while solved == false {
    //     for i in 1..=n {
    //         if potential_solution % i != 0 {
    //             break;
    //         } else {
    //             if i == n {
    //                 solution = potential_solution;
    //                 solved = true;
    //             }
    //         }
    //     }

    //     potential_solution += 1;
    // }

    // solution

    // - A more optimal solution proposed by Claude Sonnet 3.5
    let mut res = 1;
    for i in 1..=n {
        res = lcm(res, i);
    }

    res
}

// Calculate the greatest common divisor using Euclidean algorithm.
fn gcd(mut a: i64, mut b: i64) -> i64 {
    while b > 0 {
        (a, b) = (b, a % b)
    }

    a
}

// Calculate the Least Common Multiple using GCD
fn lcm(a: i64, b: i64) -> i64 {
    (a * b) / gcd(a, b)
}

// A function to compute the difference between the sum of the squares and the squre of the sum of first n numbers
pub fn prob_6(n: i64) -> i64 {
    // let mut sum_of_square = 0;
    // let mut sum = 0;

    // for i in 1..=n {
    //     // sume of the square
    //     sum_of_square += i * i;

    //     // squre of the sum
    //     sum += i;
    // }

    // (sum * sum) - sum_of_square

    // A more optimal solution generated by Claude Sonnet 3.5
    let sum = n * (n + 1) / 2;
    let sum_of_squares = n * (n + 1) * (2 * n + 1) / 6;

    (sum * sum) - sum_of_squares
}

// A function to return the nth prome number
pub fn prob_7(n: i64) -> i64 {
    let mut count = 1; // we know that 2 is a prime number
    let mut candidate = 1;
    while count < n {
        candidate += 2;
        if is_prime(candidate) {
            count += 1
        }
    }

    candidate
}

fn is_prime(n: i64) -> bool {
    if n == 1 {
        return false;
    } else if n < 4 {
        return true; // 2 and 3 are prime numbers
    } else if n % 2 == 0 {
        return false;
    } else if n < 9 {
        return true; // we already excluded 4, 6, 8
    } else if n % 3 == 0 {
        return false; // can clearly be divided by a number that is not 1 or itself. NB: we have excluded 3 itself
    } else {
        let r = (n as f64).sqrt() as i64; // round to the greatest integer so that r*r <= n
        let mut f = 5;
        while f <= r {
            if n % f == 0 || n % (f + 2) == 0 {
                return false;
            }
            f = f + 6;
        }
    }

    true
}

// A function to provide the n adjacent numbers with the higest product.
pub fn prob_8(n: i64) -> i64 {
    let digits = "73167176531330624919225119674426574742355349194934
    96983520312774506326239578318016984801869478851843
    85861560789112949495459501737958331952853208805511
    12540698747158523863050715693290963295227443043557
    66896648950445244523161731856403098711121722383113
    62229893423380308135336276614282806444486645238749
    30358907296290491560440772390713810515859307960866
    70172427121883998797908792274921901699720888093776
    65727333001053367881220235421809751254540594752243
    52584907711670556013604839586446706324415722155397
    53697817977846174064955149290862569321978468622482
    83972241375657056057490261407972968652414535100474
    82166370484403199890008895243450658541227588666881
    16427171479924442928230863465674813919123162824586
    17866458359124566529476545682848912883142607690042
    24219022671055626321111109370544217506941658960408
    07198403850962455444362981230987879927244284909188
    84580156166097919133875499200524063689912560717606
    05886116467109405077541002256983155200055935729725
    71636269561882670428252483600823257530420752963450"
        .to_string();

    // concert input to a vec of integers
    let digits: Vec<i64> = digits
        .chars()
        .filter(|c| c.is_digit(10))
        .map(|c| c.to_digit(10).unwrap() as i64)
        .collect();

    // Compute the n adjacent numbers using a sliding window and selecting the max
    digits
        .windows(n as usize)
        .map(|window| window.iter().product())
        .max()
        .unwrap_or(0)
}

// A function to produce the Pythagorean triple for which a + b + c = n
pub fn prob_9(n: i64) -> i64 {
    // a should be max of n/3 because a < b < c
    for a in 1..n / 3 {
        // For each a, b should range from a+1 to (n-a)/2 since c > b
        for b in (a + 1)..(n - a) / 2 {
            // c = n - a - b from the equation
            let c = n - a - b;

            // check if it forms a Pythagorean triple
            if a * a + b * b == c * c {
                // if a valid triple, return the product
                return a * b * c;
            }
        }
    }

    // If no solution found, return 0
    0
}

pub fn prob_9_optimised(s: i64) -> i64 {
    let m_limit = 100; // can be tuned
    let s2 = s / 2;

    for m in 2..=m_limit {
        if s2 % m == 0 {
            let mut sm = s2 / m;

            // Remove all factors of 2 from sm
            while sm % 2 == 0 {
                sm /= 2;
            }

            let mut k = if m % 2 == 1 { m + 2 } else { m + 1 };

            while k < 2 * m && k <= sm {
                if sm % k == 0 && gcd(k, m) == 1 {
                    let d = s2 / (k * m);
                    let n = k - m;
                    let a = d * (m * m - n * n);
                    let b = 2 * d * m * n;
                    let c = d * (m * m + n * n);
                    return a * b * c; // return the product of the triplet
                }
                k += 2;
            }
        }
    }

    // If no solution found, return 0
    0
}

pub fn prob_10(n: i64) -> i64 {
    let mut count = 0;
    let mut sum = 0;
    for i in 0..n {
        if count < n {
            if is_prime(i) {
                sum += i
            }
            count += 1;
        }
    }

    sum
}

pub fn prob_11() -> i128 {
    let grid = [
        [
            08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08,
        ],
        [
            49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00,
        ],
        [
            81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65,
        ],
        [
            52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91,
        ],
        [
            22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80,
        ],
        [
            24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50,
        ],
        [
            32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70,
        ],
        [
            67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21,
        ],
        [
            24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72,
        ],
        [
            21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95,
        ],
        [
            78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92,
        ],
        [
            16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57,
        ],
        [
            86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58,
        ],
        [
            19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40,
        ],
        [
            04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66,
        ],
        [
            88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69,
        ],
        [
            04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36,
        ],
        [
            20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16,
        ],
        [
            20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54,
        ],
        [
            01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48,
        ],
    ];
    let mut max_prod = 0;
    let row = grid.len();
    let column = grid[0].len();

    for r in 0..row {
        for c in 0..column {
            // Horizontal (right)
            if c + 3 < 20 {
                let p = grid[r][c] * grid[r][c + 1] * grid[r][c + 2] * grid[r][c + 3];
                max_prod = std::cmp::max(max_prod, p);
            }

            // Vertical (down)
            if r + 3 < 20 {
                let p = grid[r][c] * grid[r + 1][c] * grid[r + 2][c] * grid[r + 3][c];
                max_prod = std::cmp::max(max_prod, p);
            }

            // Diagonal down - right
            if r + 3 < 20 && c + 3 < 20 {
                let p = grid[r][c] * grid[r + 1][c + 1] * grid[r + 2][c + 2] * grid[r + 3][c + 3];
                max_prod = std::cmp::max(max_prod, p);
            }

            // Diagonal down - left
            if r + 3 < 20 && c >= 3 {
                let p = grid[r][c] * grid[r + 1][c - 1] * grid[r + 2][c - 2] * grid[r + 3][c - 3];
                max_prod = std::cmp::max(max_prod, p);
            }
        }
    }

    max_prod
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn prob_1_test() {
        let sum = prob_1(10);
        assert_eq!(sum, 23);
    }

    #[test]
    fn prob_2_test() {
        let res = prob_2(89);
        assert_eq!(res, 44);
    }

    #[test]
    fn prob_3_test() {
        let res = prob_3(13195);
        assert_eq!(res, 29);
    }

    #[test]
    fn prob_4_test() {
        let res = prob_4();
        assert_eq!(res, 906609);
    }

    #[test]
    fn prob_5_test() {
        let res = prob_5(10);
        assert_eq!(res, 2520);
    }

    #[test]
    fn prob_6_test() {
        let res = prob_6(10);
        assert_eq!(res, 2640);
    }

    #[test]
    fn prob_7_test() {
        let res = prob_7(6);
        assert_eq!(res, 13);
    }

    #[test]
    fn prob_8_test() {
        let res = prob_8(4);
        assert_eq!(res, 5832);
    }

    #[test]
    fn prob_9_test() {
        let res = prob_9(1000);
        assert_eq!(res, 31875000);

        // optimised solution
        let res = prob_9_optimised(12);
        assert_eq!(res, 60);

        let res = prob_9_optimised(1000);
        assert_eq!(res, 31875000);
    }

    #[test]
    fn prob_10_test() {
        let res = prob_10(10);
        assert_eq!(res, 17);
    }

    #[test]
    fn prob_11_test() {
        let res = prob_11();
        assert_eq!(res, 70600674);
    }
}
